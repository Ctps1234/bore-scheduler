diff -uprN a/kernel/sched/core.c b/kernel/sched/core.c
--- a/kernel/sched/core.c	2021-12-15 20:19:19.971289662 +0900
+++ b/kernel/sched/core.c	2021-12-15 20:09:29.385146880 +0900
@@ -8122,8 +8122,6 @@ static void do_sched_yield(void)
 	struct task_struct *curr = current;
 	struct bs_node *cn = &curr->se.bs_node;
 
-	cn->yield_flag = true;
-	
 	rq = this_rq_lock_irq(&rf);
 
 	schedstat_inc(rq->yld_count);
diff -uprN a/kernel/sched/fair.c b/kernel/sched/fair.c
--- a/kernel/sched/fair.c	2021-12-15 20:19:19.973289616 +0900
+++ b/kernel/sched/fair.c	2021-12-15 20:09:26.517151856 +0900
@@ -35,16 +35,13 @@
 
 unsigned int __read_mostly sysctl_sched_tick_preempt_threshold_ns    =  100000;
 unsigned int __read_mostly sysctl_sched_wakeup_preempt_threshold_ns  =   10000;
-unsigned int __read_mostly sysctl_sched_greedy_task_aggressiveness   =       5;
+unsigned int __read_mostly sysctl_sched_greedy_task_aggressiveness   =       0;
 
 void bs_sched_update_internals(void)
 {
 }
 
-void __init sched_init_bs_sched(void)
-{
-	bs_sched_update_internals();
-}
+void __init sched_init_bs_sched(void) {bs_sched_update_internals();}
 
 int sched_proc_update_handler(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp, loff_t *ppos)
@@ -553,17 +550,17 @@ calc_score(u64 now, struct bs_node *bsn,
 {
 	struct sched_entity *se = se_of(bsn);
 	struct cfs_rq *cfs_rq = cfs_rq_of(se);
-	u64 wait_factor, burst_score, greed_score, power, resist;
+	u64 time_factor, burst_score, greed_score, power, resist;
 	
 	if(se == cfs_rq->curr) {
 		if(unlikely(bsn->yield_flag)) return BS_SCHED_MIN_SCORE;
-		wait_factor = wakeup ? sysctl_sched_wakeup_preempt_threshold_ns
+		time_factor = wakeup ? sysctl_sched_wakeup_preempt_threshold_ns
 		                     : sysctl_sched_tick_preempt_threshold_ns;
 	} else {
-		wait_factor = now - bsn->waiting_since;
-		if(unlikely(wait_factor >= BS_SCHED_MAX_TIME)) return BS_SCHED_MAX_SCORE;
+		time_factor = now - bsn->waiting_since;
+		if(unlikely(time_factor >= BS_SCHED_MAX_TIME)) return BS_SCHED_MAX_SCORE;
 	}
-	power = wait_factor * scale_load_down(se->load.weight) << 7;
+	power = time_factor * scale_load_down(se->load.weight) << 7;
 	
 	greed_score = bsn->greed_score;
 	burst_score = bsn->burst_time +
@@ -6843,6 +6840,8 @@ static void yield_task_fair(struct rq *r
 	if (unlikely(rq->nr_running == 1))
 		return;
 
+	se->bs_node.yield_flag = true;
+	
 	if (curr->policy != SCHED_BATCH) {
 		update_rq_clock(rq);
 		/*
